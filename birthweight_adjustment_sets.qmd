---
title: "Birthweight Application"
format: pdf
editor: source
---

```{r}
library(tidyverse)
library(truncdist)
library(nnet)
library(car)
library(randomForest) 
library(tidybayes)
library(bayesplot)
library(gsynth)
library(colorspace)
library(ggbeeswarm)
source("utilities.R")
```

```{r}
# saveRDS(merged_bw_df_selected, file = "birthweight_data_preprocess.rds")
merged_bw_df_selected <- readRDS("data/birthweight_data_preprocess.rds")
raw_names <- colnames(merged_bw_df_selected)[11:35]
colnames(merged_bw_df_selected)[11:35] <- paste0("x", 1:25)
```

DML random forest.

```{r}
x <- merged_bw_df_selected[, c(2,4:5,7,11:35)]
d <- merged_bw_df_selected[,]$pm25
y <- merged_bw_df_selected[,]$bw_mean

set.seed(202505)

#DML with Random Forest:
dreg <- function(x,d){randomForest(x, d)} 
yreg <- function(x,y){randomForest(x, y)} 

```

```{r}
run_analysis <- function(data,
                         adj_cols = character(0L),   # adjustment set X
                         d_col     = "pm25",          # treatment   column
                         y_col     = "bw_mean",       # outcome     column
                         unit_col  = "unit",          # ID for interFE
                         time_col  = "time",          # ID for interFE
                         T_periods = 7L,              # # of time points
                         M_factors = 3L,              # # of latent factors in Stan
                         nfold     = 5L,
                         vb_draws  = 2000L,
                         seed      = 123) {

  ## 1.1 Split variables -------------------------------------------
  X <- if (length(adj_cols)) data[, adj_cols, drop = FALSE] else NULL
  d <- data[[d_col]]
  y <- data[[y_col]]

  ## 1.2 DML --------------------------------------------------------
  set.seed(seed)
  dml_fit <- dml_plm(X, d, y, dreg, yreg, nfold = nfold)

  coef_hat <- as.numeric(dml_fit$coef.est)
  se_hat   <- as.numeric(dml_fit$se)
  ci_95    <- coef_hat + c(-1.96, 1.96) * se_hat

  ## 1.3  Residuals to matrices -------------------------------------
  resD_mat <- matrix(dml_fit$resD, ncol = 7, byrow = TRUE)
  resY_mat <- matrix(dml_fit$resY, ncol = 7, byrow = TRUE)

  ## 1.4  Stan (Factor model VB) ------------------------------------
  N_units <- nrow(resD_mat)
  stan_data <- list(
    K = T_periods, Q = T_periods, N = N_units,
    M = M_factors, d = resD_mat,  y = resY_mat
  )
  sm_factor <- cmdstanr::cmdstan_model("stan/time_nc_factor.stan")
  vb_fit <- sm_factor$variational(data = stan_data, seed = seed, draws = vb_draws)
  vb_sum <- posterior::summarise_draws(
              vb_fit$draws("beta"),
              mean,
              ~quantile(.x, probs = c(0.025, 0.975))
            )

  ## 1.5  interFE ---------------------------------------------------
  df_fe <- data.frame(
            unit = rep(1:N_units, each = T_periods), # unit
            time = rep(1:T_periods, N_units),
            Y    = dml_fit$resY,
            D    = dml_fit$resD
          )
  # flip time and unit does not change much
  fe_fit <- interFE(Y ~ D, data = df_fe,
                    index = c("unit", "time"),
                    r     = M_factors,
                    force = "none",
                    nboots = 100)

  ## 1.6  Return --------------------------------------------
  list(
    adj_set     = adj_cols,
    dml_coef    = coef_hat,
    dml_ci_95   = ci_95,
    vb_summary  = vb_sum,
    interFE_est = fe_fit$beta
  )
}
```

```{r}

# Set up parallel processing
cov_list <- list(income=7, age = 11:19, race = 20:26, educ=27:30, foreign = 31, care = 32:35)

# Create a list of all tasks to run in parallel
all_tasks <- list()
task_id <- 1

for(i in 6:0) {
  combinations <- combn(6, i)
  for(j in 1:ncol(combinations)) {
    indices <- unlist(cov_list[combinations[, j]])
    adj_cols <- colnames(merged_bw_df_selected)[c(2, 4:5, indices)]
    
    # Store each task as a list
    all_tasks[[task_id]] <- list(
      i = i,
      j = j,
      adj_cols = adj_cols
    )
    task_id <- task_id + 1
  }
}

cat("Total tasks to run:", length(all_tasks), "\n")

# Define a function to run a single task
run_single_task <- function(task) {
  result <- run_analysis(merged_bw_df_selected, adj_cols = task$adj_cols)
  return(list(
    i = task$i,
    j = task$j,
    result = result
  ))
}

# Run all tasks in parallel
cat("Starting parallel processing...\n")
start_time <- Sys.time()

library(future)
library(future.apply)

# Set up parallel backend
plan(multicore, workers = 32)

# Run in parallel
all_results <- future_lapply(
  all_tasks,
  run_single_task,
  future.seed = TRUE
)

end_time <- Sys.time()
cat("Parallel processing completed in:", round(difftime(end_time, start_time, units = "mins"), 2), "minutes\n")

# Reorganize results back into the original nested structure
results_list <- list()
for(i in 6:0) {
  results_list[[as.character(i)]] <- list()
}

for(task_result in all_results) {
  i <- task_result$i
  j <- task_result$j
  results_list[[as.character(i)]][[j]] <- task_result$result
}

# Save results
saveRDS(results_list, file = "results_list3.RDS")
cat("Results saved to results_list.RDS\n")
```

```{r}
# Extract results from results_list
results_list <- readRDS("results_list3.RDS")

# Create a function to extract estimates from each result
extract_estimates <- function(result) {
  list(
    dml_coef = result$dml_coef,
    factor_conf = result$vb_summary$mean,
    interFE_est = result$interFE_est
  )
}

combination_names <- c(
  "All 6 covariates",
  "Any 5 covariates", 
  "Any 4 covariates",
  "Any 3 covariates", 
  "Any 2 covariates",
  "Any 1 covariate",
  "No covariates"
)

# Extract all estimates
plot_data <- tibble()

for(i in 6:0) {
  len <- length(results_list[[as.character(i)]])
  if(len > 0) {
    # For each combination at level i
    estimates_i <- map(results_list[[as.character(i)]], extract_estimates)
    
    # Calculate mean estimates across all combinations at this level
    mean_dml <- map_dbl(estimates_i, "dml_coef")
    mean_factor <- map_dbl(estimates_i, "factor_conf")
    mean_interFE <- map_dbl(estimates_i, "interFE_est")
    
    # Add to plot data
    plot_data <- bind_rows(
      plot_data,
      tibble(
        setting = combination_names[7-i],
        model = rep(c("DML (NUC)", "IFE", "Factor Confounding"), each = len),
        estimate = c(mean_dml, mean_interFE, mean_factor) * 10, # Convert to per 10 µg/m³
      )
    )
  }
}

# Set factor levels to preserve order
plot_data$setting <- factor(plot_data$setting, levels = combination_names)
plot_data$model <- factor(plot_data$model, levels = c("DML (NUC)", "IFE", "Factor Confounding"))

plot_data |> group_by(setting, model) |>
  summarise(mean = mean(estimate), sd = sd(estimate), .groups = "drop") |>
  arrange(setting, sd) |>
  ggplot() + geom_col(aes(x = setting, y = sd, fill = model), position="dodge") + theme_bw(base_size = 16) + ylab("Standard Deviation of Estimates") + 
  xlab("Covariates Included") + 
  labs(fill = "Model") +
  # scale_fill_manual(values = c("DML (NUC)" = "#0072B2",
  #                                "Factor Confounding" = "firebrick",
  #                                "IFE" = "#009E73")) 
  scale_fill_discrete_qualitative(palette = "Dark 3") +
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 30, hjust = 0.9),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) ->
        p_sd

p_sd


plot_data |> group_by(setting, model) |>
  summarise(rmse = sqrt(mean((estimate + 16)^2)), sd = sd(estimate), .groups = "drop") |>
  filter(!is.na(rmse)) |>
  arrange(setting, rmse) |>
  ggplot() + geom_col(aes(x = setting, y = rmse, fill = model), position="dodge") + theme_bw(base_size = 16) + ylab("Root mean squared difference\nfrom -16g per 10 µg/m³") + 
  xlab("Covariates Included") + 
  labs(fill = "Model") +
  # scale_fill_manual(values = c("DML (NUC)" = "#0072B2",
  #                                "Factor Confounding" = "firebrick",
  #                                "IFE" = "#009E73")) 
  scale_fill_discrete_qualitative(palette = "Dark 3") +
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 30, hjust = 0.9),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) ->
        p_rmse

p_rmse

(p_rmse + xlab(NULL) + theme(axis.text.x = element_blank())) / (p_sd + theme(legend.position = "none")) + plot_annotation(tag_levels = "A")

ggsave("sd_rmse.png", width=6, height=10)

plot_data |> group_by(setting, model) |>
  summarise(median = median(estimate), sd = sd(estimate), .groups = "drop") |>
  arrange(setting, sd) |>
  ggplot() + geom_col(aes(x = setting, y = median, fill = model), position="dodge") + theme_bw(base_size = 16) + 
  # scale_fill_manual(values = c("DML (NUC)" = "#0072B2",
  #                                "Factor Confounding" = "firebrick",
  #                                "IFE" = "#009E73")) +
  scale_fill_discrete_qualitative(palette = "Dark 3") +
  ylab("Median of Estimates") + 
  xlab("Covariates Included") + 
  labs(fill = "Model") +
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 30, hjust = 0.9),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank()) ->
        p_median
p_median
ggsave("sensitivity_median.png", width=6, height=6)
# Create the plot
p_combinations <- ggplot(plot_data,
       aes(x = setting,
           y = estimate,
           colour = model)) +
  geom_point(position = position_dodge(width = .35),
             size = 2) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "",
       x = "Covariates Included",
       y = "Birthweight change (g)\nper 10 µg/m³ PM2.5 increase",
       colour = "Model") +
  # scale_colour_manual(values = c("DML (NUC)" = "#0072B2",
  #                                "Factor Confounding" = "firebrick",
  #                                "IFE" = "#009E73")) +
  scale_colour_discrete_qualitative(palette = "Dark 3") +
  theme_bw(base_size = 16) +
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 30, hjust = 0.9),
        panel.grid.minor = element_blank())

p_combinations





# Create the beehive plot
p_beehive <- ggplot(plot_data,
       aes(x = setting,
           y = estimate,
           colour = model)) +
  geom_beeswarm(size = 2, 
                dodge.width = 0.7,
                alpha = 0.7) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey50") +
  # stat_summary(aes(group = model),
  #              fun = mean,
  #              geom = "point",
  #              size = 3,
  #              shape = 18,  # diamond shape for means
  #              position = position_dodge(width = 0.7)) +
  labs(title = "",
       x = "Covariates Included",
       y = "Birthweight change (g)\nper 10 µg/m³ PM2.5 increase",
       colour = "Model") +
  # scale_colour_manual(values = c("DML (NUC)" = "#0072B2",
  #                                "Factor Confounding" = "firebrick",
  #                                "IFE" = "#009E73")) +
  scale_colour_discrete_qualitative(palette = "Dark 3") +
  theme_bw(base_size = 16) +
  theme(legend.position = "top",
        axis.text.x = element_text(angle = 30, hjust = 0.9),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

p_beehive

ggsave("beehive.png", width=6, height=6)

library(patchwork)

(p_beehive + (p_rmse + xlab(NULL) + theme(axis.text.x = element_blank()))) /
(p_beehive + (p_sd + theme(legend.position = "none"))) + plot_annotation(tag_levels = "A")
ggsave("birthweight_all_plots.png")

p_beehive + (p_median / p_sd) + 
  plot_annotation(title = "Sensitivity to Included Covariates",
                  subtitle = "Beeswarm plot with median and standard deviation of estimates") &
  theme(plot.title = element_text(size = 20),
        plot.subtitle = element_text(size = 16))
```

## Nonlinear

```{r}
adj_cols <- colnames(merged_bw_df_selected)[c(2, 4:5, 11:35)]

## 1.1 Prepare data for Stan model -------------------------------------------
# Get covariates
X <- merged_bw_df_selected[, adj_cols, drop = FALSE]
d_raw <- merged_bw_df_selected[["pm25"]]
y_raw <- merged_bw_df_selected[["bw_mean"]]

## 1.2 Reshape data to arrays for Stan -------------------------------------
T_periods <- length(unique(merged_bw_df_selected$year))
M_factors <- 3L
num_knots <- 5
num_knots_X <- 5

N_units <- nrow(merged_bw_df_selected) / T_periods

# Reshape d and y to arrays: N_units x T_periods
d_mat <- matrix(d_raw, ncol = T_periods, byrow = TRUE)
y_mat <- matrix(y_raw, ncol = T_periods, byrow = TRUE)

# Reshape X to array: N_units x P (take first row of each unit since X is time-invariant)
X_mat <- X[seq(1, nrow(X), by = T_periods), ]
P_covs <- ncol(X_mat)

# Convert matrices to arrays for Stan
d_array <- array(NA, dim = c(N_units, T_periods))
y_array <- array(NA, dim = c(N_units, T_periods))
X_array <- array(NA, dim = c(N_units, P_covs))

for(n in 1:N_units) {
  d_array[n, ] <- d_mat[n, ]
  y_array[n, ] <- y_mat[n, ]
  X_array[n, ] <- as.numeric(X_mat[n, ])
}

# Create knot matrices
knots_d <- seq(min(d_raw), max(d_raw), length.out = num_knots)
knots_X <- matrix(NA, nrow = P_covs, ncol = num_knots_X)
for(p in 1:P_covs) {
  knots_X[p, ] <- seq(min(X_mat[, p]), max(X_mat[, p]), length.out = num_knots_X)
}

## 1.3 Stan data list ------------------------------------
stan_data <- list(
  K = T_periods, 
  Q = T_periods, 
  N = N_units,
  M = M_factors, 
  P = P_covs,
  num_knots = num_knots,
  num_knots_X = num_knots_X,
  d = d_array,  
  y = y_array,
  X = X_array,
  knots = knots_d,
  knots_X = knots_X
)

## 1.4 Fit Stan model ------------------------------------
sm_factor <- cmdstanr::cmdstan_model("stan/time_nc_factor_nonlinear.stan")
vb_fit <- sm_factor$variational(data = stan_data, seed = 1234, draws = 2000)
saveRDS(vb_fit, file = "vb_fit_nonlinear.RDS")
## 1.5 Extract and plot spline effects ------------------------------------

# Extract treatment spline coefficients (now just a single vector)
spline_coefs_draws <- posterior::as_draws_df(vb_fit$draws("spline_coefs"))
spline_coefs_summary <- posterior::summarise_draws(spline_coefs_draws)

# Get mean coefficients for plotting (now just a vector, not matrix)
spline_coefs_mean <- spline_coefs_summary$mean

# Function to evaluate B-spline basis (matching your Stan code)
eval_bspline_basis <- function(x, knots) {
  num_knots <- length(knots)
  basis <- rep(0, num_knots)
  
  for(j in 1:num_knots) {
    dist <- abs(x - knots[j])
    if(dist <= 1.0) {
      if(dist <= 0.5) {
        basis[j] <- 1 - 2 * dist^2
      } else {
        basis[j] <- 2 * (1 - dist)^2
      }
    }
  }
  return(basis)
}

# Function to evaluate spline effect
eval_spline_effect <- function(x, spline_coefs, knots) {
  basis <- eval_bspline_basis(x, knots)
  return(sum(spline_coefs * basis))
}

# Create evaluation grid
d_range <- range(stan_data$d)
d_grid <- seq(d_range[1], d_range[2], length.out = 100)

# Evaluate treatment splines (same for all time periods now)
spline_values <- sapply(d_grid, function(x) {
  eval_spline_effect(x, spline_coefs_mean, stan_data$knots)
})

plot_data_treatment <- tibble(
  treatment_value = d_grid,
  spline_effect = spline_values
)

# Plot treatment spline effects
p_spline_treatment <- ggplot(plot_data_treatment, aes(x = treatment_value, y = spline_effect)) +
  geom_line(size = 1) +
  geom_vline(xintercept = stan_data$knots, linetype = "dashed", alpha = 0.5) +
  labs(
    title = "Nonlinear Treatment Effects (PM2.5)",
    x = "PM2.5 Level", 
    y = "Spline Effect"
  ) +
  theme_bw()

p_spline_treatment

## 1.6 Extract and plot covariate spline effects ------------------------------------

# Extract covariate spline coefficients for Y model (now P x num_knots_X matrix)
spline_coefs_X_y_draws <- posterior::as_draws_df(vb_fit$draws("spline_coefs_X_y"))
spline_coefs_X_y_summary <- posterior::summarise_draws(spline_coefs_X_y_draws)

# Reshape to matrix: P x num_knots_X
spline_coefs_X_y_mean <- matrix(spline_coefs_X_y_summary$mean, nrow = P_covs, ncol = num_knots_X, byrow = TRUE)

# Plot a few covariate effects (first few covariates)
plot_data_covariates <- tibble()

for(p in 1:min(4, P_covs)) {  # Plot first 4 covariates
  # Create evaluation grid for this covariate
  x_range <- range(X_array[, p])
  x_grid <- seq(x_range[1], x_range[2], length.out = 100)
  
  spline_values <- sapply(x_grid, function(x) {
    eval_spline_effect(x, spline_coefs_X_y_mean[p, ], knots_X[p, ])
  })
  
  plot_data_covariates <- bind_rows(
    plot_data_covariates,
    tibble(
      covariate_value = x_grid,
      spline_effect = spline_values,
      covariate = paste0("Covariate_", p)
    )
  )
}

# Plot covariate spline effects
p_spline_covariates <- ggplot(plot_data_covariates, aes(x = covariate_value, y = spline_effect)) +
  geom_line(size = 1) +
  facet_wrap(~covariate, scales = "free") +
  labs(
    title = "Nonlinear Covariate Effects (same for all outcomes)",
    x = "Covariate Value", 
    y = "Spline Effect"
  ) +
  theme_bw()

p_spline_covariates
```